class Colony:

    @classmethod
    def inside(cls, x, y):
        return 0 <= x < HEIGHT and 0 <= y < WIDTH
    
    @classmethod
    def coords(cls):
        return ((line_id, col_id) for line_id in range(HEIGHT) for col_id in range(WIDTH))

    def __init__(self, filename, nb_steps=MAX_STEPS):
        self.filename = filename
        self.octopusses = []
        self.nb_steps = nb_steps
        self.nb_flashes = 0
        self.flash_positions = set() # positions where octopuss is ready to flash

    def load(self):
        with open(self.filename, 'r', encoding='utf-8') as datas:
            self.octopusses = [[int(data) for data in line.strip()] for line in datas]
    
    def __str__(self):
        s = ''
        for line_id in range(WIDTH):
            for col_id in range(HEIGHT):
                s += str(self.octopusses[line_id][col_id])
            s += '\n'
        return s

    def neighboors(self, x, y):
        return ((x+dx, y+dy) for dx, dy in DELTAS if Colony.inside(x+dx, y+dy))

    def add_critical(self, line_id, col_id):
        if self.octopusses[line_id][col_id] == CRITICAL:
            self.flash_positions.add((line_id, col_id))

    def energy_up(self):
        for line_id, col_id in Colony.coords():
            self.octopusses[line_id][col_id] += 1
            self.add_critical(line_id, col_id)

    def flash(self):
        just_flashed = set()
        while self.flash_positions:
            line_id, col_id = self.flash_positions.pop()
            self.nb_flashes += 1
            self.octopusses[line_id][col_id] = EMPTY
            just_flashed.add((line_id, col_id))
            for l, c in self.neighboors(line_id, col_id):
                if (l, c) not in just_flashed:
                    self.octopusses[l][c] += 1
                    self.add_critical(l, c)

    def step(self):
        self.energy_up()
        self.flash()
        
    
    def solve(self):
        self.load()
        # print(self)
        # print()
        for i in range(self.nb_steps):
            self.step()
            # print('after step', i+1)
            # print(self)
            # input()